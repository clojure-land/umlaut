// Foundational types

@lang/dot color olivedrab1
interface RootNode {
  id: ID {
    @doc "Relay-specific opaque ID of this entity. It must always return the same entity as represented by the server at that request time."
  }
}

type Version {
  systemId: String {
    @doc "The ID of the system this version refers to"
  }
  description: String? {
    @doc "A free-form description of the system this version refers to"
  }
  semver: String {
    @doc "The semver version of the system"
  }
}

@lang/dot color lightgoldenrod1
@doc "Defines the type of the image that can be fetched."
enum ImageType {
  PNG SVG
}

@lang/dot color lightgoldenrod1
@doc "Speficifies the size of the image that can be fetched. The standard follows the Human Interface Guidelines from Apple"
enum ImageSizeType {
  SIZE_3X SIZE_2X SIZE_1X
}

@lang/dot color lightgoldenrod1
@doc "Represent a combination of image type, size, and URL to fetch the particular image asset."
type Image {
  type: ImageType {
    @doc "The type of the image."
  }
  sizeType: ImageSizeType {
    @doc "The size of the image."
  }
  url: String {
    @doc "The URL where the image can be fetched from."
  }
}

@lang/dot color lightgoldenrod1
@doc "Top level node for any parent types that render on the screen."
type ViewerNode : RootNode {
  carouselItems(storeId: ID?): CarouselItemNode[1..n] {
    @lang/lacinia resolver resolve-carousel-items
  }
  stores(locationSearch: LocationSearchInput?): StoreNode[0..n] {
    @lang/lacinia resolver resolve-stores
  }
  versions: Version[0..n]
  cities: CityNode[0..n] {
    @lang/lacinia resolver resolve-cities
  }
  productsCatalog(storeId: ID?): ProductNode[0..n] {
    @lang/lacinia resolver resolve-products-catalog
  }
}

// Location types

@lang/lacinia identifier input
type LocationSearchInput {
  latitude: Float
  longitude: Float
  radius: Float
}

// Store types

@lang/dot color indianred1
@doc "Represents a store object, prop-types subject to change.."
type StoreNode : RootNode {
  name: String
  address: String
  city: String {
    @lang/lacinia resolver resolve-city
  }
  phone: String
  monFriHours: String
  satSunHours: String
  latitude: Float
  longitude: Float
  distance: Float?
}

type CityNode : RootNode {
  name: String
  stores: StoreNode[0..n] {
    @lang/lacinia resolver resolve-stores
  }
}

@lang/lacinia identifier union
@lang/graphql identifier union
@lang/dot color olivedrab1
enum VariantNode {
  VariantSizeNode VariantCreamNode VariantSweetenerNode
}

@lang/dot color olivedrab1
enum CreamAmount {
  EXTRA MEDIUM LIGHT NONE
}

@lang/dot color olivedrab1
enum SweetenerAmount {
  EXTRA MEDIUM LIGHT NONE
}

@lang/dot color olivedrab1
enum SizeType {
  LARGE SMALL
}

@lang/dot color olivedrab1
enum SweetenerType {
  SUGAR HONEY SPLENDA STEVIA SWEETNLOW EQUAL
}

@lang/dot color olivedrab1
enum CreamType {
  CREAM WHOLE TWO_PERCENT LOW_FAT NON_FAT ALMOND SOY VANILLA_SOY
}

@lang/dot color olivedrab1
@doc "Represents one product in the Menu, or one of many underlying products in a carousel item."
@lang/spec validator validate-product
type ProductNode : RootNode {
  name: String
  image: Image[1..n]
  backgroundColor: String
  foregroundColor: String
  textFormatter: String
  availableVariants: VariantNode[1..n]
  selectedVariants: VariantNode[0..n]
  defaultVariants: VariantNode[1..n]
  description: String
  // mint, cardamom...etc.
  productFlags: ProductFlagNode[0..n]
  specialInstructions: String?
  price: Float
  isAvailable: Boolean
  productType: ProductType
  blendType: BlendType
}

@lang/dot color olivedrab1
@lang/spec validator validate-blend-type
enum BlendType {
  DARK MEDIUM LIGHT ICED DECAF TEA
}

@lang/dot color olivedrab1
enum ProductType {
  COFFEE TEA
}

@lang/dot color olivedrab1
type VariantSizeNode : RootNode {
  type: SizeType
  additionalPrice: Float
}

@lang/dot color olivedrab1
type VariantCreamNode : RootNode {
  amount: CreamAmount
  type: CreamType
}

@lang/dot color olivedrab1
type VariantSweetenerNode : RootNode {
  amount: SweetenerAmount
  type: SweetenerType
}

@doc "Represents a carousel item on the home screen. Note that a carousel items are not identical in data shape because they can be an order, or a favorite item."
@lang/dot color olivedrab1
interface CarouselItemNode {
  title: String
  description: String
  products: ProductNode[1..n]
}

@lang/dot color olivedrab1
@doc "A Carousel Recommendation, is an API-recomennded product. When the user downloads the app for the first time, all carousel items will be of this type because the user has not made any orders and does not have any favorites."
type CarouselRecommendationNode : RootNode CarouselItemNode {
  estimates(limit: Integer?): String[0..n] {
    @doc "given a number of items, you get a collection of times in string RFC3339 format, of estimates that a user can pick their order."
  }
}

@lang/dot color olivedrab1
@doc "This node can be thought of a previously ordered bundle"
type CarouselFavoriteNode : RootNode CarouselItemNode {
  estimates(limit: Integer?): String[0..n] {
    @doc "given a number of items, you get a collection of times in string RFC3339 format, of estimates that a user can pick their order."
  }
}

@lang/dot color lightgoldenrod1
@doc "This node represents an active order"
type CarouselOrderNode : RootNode CarouselItemNode {
  orderStatus: OrderStatus
  baristaImage: Image[1..n]
  store: StoreNode
  orderPickUpTime: String // RFC3339 format.
}

@lang/dot color lightgoldenrod1
enum OrderStatus {
  UNASSIGNED ASSIGNED READY CANCELLED
}

@lang/dot color olivedrab1
type ProductFlagNode : RootNode {
  icon: Image[1..n]
  name: String
}

// Feedbacks

enum RateType {
  HAPPY UNHAPPY
}

type RateNode : RootNode {
  order: OrderNode?
  rateType: RateType
}

type Feedback {
  comments: String
}

// Order types

type CartNode : RootNode {
  products: ProductNode[1..n]
  totalCount: Integer
  totalPrice: Float
  totalTax: Float
}

type OrderNode : RootNode {
  products: ProductNode[1..n]
  totalCount: Integer
  totalPrice: Float
  totalTax: Float
}

// Putting it all together

@lang/dot color lightgoldenrod1
@lang/lacinia identifier query
type QueryRoot {
  viewer: ViewerNode? {
    @lang/lacinia resolver resolve-viewer
  }
  node(id: ID): RootNode? {
    @lang/lacinia resolver resolve-node
  }
}

@lang/lacinia identifier mutation
type MutationRoot {
  rateOrder(orderId: ID, rate: RateType): RateNode
  feedback(rateId: ID?, comments: String): Feedback
}

diagram Products {
  (QueryRoot ViewerNode RootNode)
  (ProductNode CarouselItemNode CarouselRecommendationNode CarouselFavoriteNode CarouselOrderNode)!
}

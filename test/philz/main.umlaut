// Foundational types

interface RootNode {
  id: ID
}

@lang/graphql identifier schema
type schema {
  query: QueryRoot
}

type PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String?
  endCursor: String?
}

@lang/lacinia resolver stores resolve-stores
type ViewerNode : RootNode {
  id: ID
  productGroups: ProductGroupNode[1..n]
  stores(locationSearch: LocationSearchInput?, first: Integer?, after: String?): StoreConnection
}

// Location types

@lang/lacinia identifier input
type LocationSearchInput {
  latitude: Float
  longitude: Float
  radius: Float
}

// Store types

type StoreConnection {
  edges: StoreEdge[1..n]?
  pageInfo: PageInfo
}

type StoreEdge {
  cursor: String
  node: StoreNode
}

type StoreNode : RootNode {
  id: ID
  name: String
  address: String
  latitude: Float
  longitude: Float
  distance: Float?
}

// Product types

type ProductNode : RootNode {
  id: ID
  name: String
  cupImageSrc: String
  backgroundColor: String
  foregroundColor: String
  variantSelections: VariantSelection[1..n]
  availableVariants: AvailableVariant[1..n]
  ingredientDescription: String
  ingredientFlags: IngredientFlag[0..n]
  specialInstructions: String?
  price: Float
  isAvailable: Boolean
}

type ProductGroupNode : RootNode {
  id: ID
  products: ProductNode[1..n]
  callToAction: String
  soonestAvailableTimeFrame: TimeFrame?
  availableSchedules: ScheduleEntry[0..n]?
}

type AvailableVariant {
  textPrefix: String
  textSuffix: String
  variantQuantifiers: VariantQuantifier[0..n]
  variantType: KeyValuePair
  variantValues: KeyValuePair[1..n]
}

type VariantQuantifier {
  relativeQty: Integer
  text: String
}

type VariantSelection {
  variantType: KeyValuePair
  variantValue: KeyValuePair
  variantQuantifier: VariantQuantifier?
}

type IngredientFlag {
  imageSrc: String
  text: String
}

type KeyValuePair {
  key: String
  value: String
}

// Order types

type CartNode : RootNode {
  id: ID
  products: ProductNode[1..n]
  totalCount: Integer
  totalPrice: Float
  totalTax: Float
}

type TimeFrame {
  dateTime: String
  offsetInMins: Integer
}

type ScheduleEntry {
  timeFrame: TimeFrame
  available: Boolean
}

// Putting it all together

@lang/lacinia identifier query
@lang/lacinia resolver viewer resolve-viewer
@lang/lacinia resolver node resolve-node
type QueryRoot {
  viewer(): ViewerNode?
  node(id: ID): RootNode?
}

diagram philz {
  (RootNode ViewerNode)!
}
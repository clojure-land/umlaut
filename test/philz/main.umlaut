// Foundational types

interface RootNode {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String?
  endCursor: String?
}

type Version {
  systemID: String
  description: String?
  semver: String
}

type ViewerNode : RootNode {
  productGroups: ProductGroupNode[1..n]
  stores(locationSearch: LocationSearchInput?, first: Integer?, after: String?): StoreConnection {
    @lang/lacinia resolver resolve-stores
  }
  versions: Version[0..n]
  cities: CityNode[0..n] {
    @lang/lacinia resolver resolve-cities
  }
}

// Location types

@lang/lacinia identifier input
type LocationSearchInput {
  latitude: Float
  longitude: Float
  radius: Float
}

// Store types

type StoreConnection {
  edges: StoreEdge[1..n]?
  pageInfo: PageInfo
}

type StoreEdge {
  cursor: String
  node: StoreNode
}

type StoreNode : RootNode {
  name: String
  address: String
  city: CityNode
  phone: String
  monFriHours: String
  satSunHours: String
  latitude: Float
  longitude: Float
  distance: Float?
}

type CityNode : RootNode {
  name: String
  stores: StoreNode[0..n]
}

// Product types

type ProductNode : RootNode {
  name: String
  cupImageSrc: String
  backgroundColor: String
  foregroundColor: String
  variantSelections: VariantSelection[1..n]
  availableVariants: AvailableVariant[1..n]
  ingredientDescription: String
  ingredientFlags: IngredientFlag[0..n]
  specialInstructions: String?
  price: Float
  isAvailable: Boolean
}

type ProductGroupNode : RootNode {
  products: ProductNode[1..n]
  callToAction: String
  soonestAvailableTimeFrame: TimeFrame?
  availableSchedules: ScheduleEntry[0..n]?
}

type AvailableVariant {
  textPrefix: String
  textSuffix: String
  variantQuantifiers: VariantQuantifier[0..n]
  variantType: KeyValuePair
  variantValues: KeyValuePair[1..n]
}

type VariantQuantifier {
  relativeQty: Integer
  text: String
}

type VariantSelection {
  variantType: KeyValuePair
  variantValue: KeyValuePair
  variantQuantifier: VariantQuantifier?
}

type IngredientFlag {
  imageSrc: String
  text: String
}

type KeyValuePair {
  key: String
  value: String
}

// Feedbacks

enum RateType {
  HAPPY UNHAPPY
}

type RateNode : RootNode {
  id: ID
  order: OrderNode?
  rateType: RateType
}

type Feedback {
  comments: String
}


// Order types

type CartNode : RootNode {
  products: ProductNode[1..n]
  totalCount: Integer
  totalPrice: Float
  totalTax: Float
}

type OrderNode : RootNode {
  products: ProductNode[1..n]
  totalCount: Integer
  totalPrice: Float
  totalTax: Float
}

type TimeFrame {
  dateTime: String
  offsetInMins: Integer
}

type ScheduleEntry {
  timeFrame: TimeFrame
  available: Boolean
}

// Putting it all together

@lang/lacinia identifier query
type QueryRoot {
  viewer: ViewerNode? {
    @lang/lacinia resolver resolve-viewer
  }
  node(id: ID): RootNode? {
    @lang/lacinia resolver resolve-node
  }
}

@lang/lacinia identifier mutation
type MutationBla {
  rateOrder(orderID: ID, rate: RateType): RateNode
  feedback(rateID: ID?, comments: String): Feedback
}

diagram philz {
  (QueryRoot)!
}